{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "adf-fabric-test"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/ds_raw_json_files')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_fabrictest",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 Raw"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileSystem": "raw"
					}
				},
				"schema": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_raw_orders')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_fabrictest",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 Raw"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "orders.parquet",
						"fileSystem": "raw"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_sink_order_items_df')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_fabrictest",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "order_items.csv",
						"folderPath": "df_sink",
						"fileSystem": "filescopytest"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_sink_stories')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_fabrictest",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Misc"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "sink",
						"fileSystem": "filescopytest"
					}
				},
				"schema": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stories')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_fabrictest",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Misc"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "source/stores_test",
						"fileSystem": "filescopytest"
					}
				},
				"schema": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_structured_orders')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_fabrictest",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "04 Structured"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "orders",
						"fileSystem": "structured"
					},
					"compressionCodec": "snappy"
				},
				"schema": [
					{
						"name": "ORDER_ID",
						"type": "INT32"
					},
					{
						"name": "ORDER_DATE",
						"type": "DATE"
					},
					{
						"name": "CUSTOMER_ID",
						"type": "INT32"
					},
					{
						"name": "STORE_ID",
						"type": "INT32"
					},
					{
						"name": "ORDER_STATUS",
						"type": "UTF8"
					},
					{
						"name": "PRODUCT_ID",
						"type": "INT32"
					},
					{
						"name": "UNIT_PRICE",
						"type": "DOUBLE"
					},
					{
						"name": "QUANTITY",
						"type": "INT32"
					},
					{
						"name": "SUBTOTAL",
						"type": "DOUBLE"
					},
					{
						"name": "UPDATED_TIMESTAMP",
						"type": "INT96"
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_structured_products')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_fabrictest",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "04 Structured"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "products",
						"fileSystem": "structured"
					},
					"compressionCodec": "snappy"
				},
				"schema": [
					{
						"name": "PRODUCT_ID",
						"type": "INT32"
					},
					{
						"name": "PRODUCT_NAME",
						"type": "UTF8"
					},
					{
						"name": "UNIT_PRICE",
						"type": "DOUBLE"
					},
					{
						"name": "UPDATE_TIMESTAMP",
						"type": "INT96"
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_structured_stores')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_fabrictest",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "04 Structured"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "stores",
						"fileSystem": "structured"
					},
					"compressionCodec": "snappy"
				},
				"schema": [
					{
						"name": "STORE_ID",
						"type": "INT32"
					},
					{
						"name": "STORE_NAME",
						"type": "UTF8"
					},
					{
						"name": "LATITUDE",
						"type": "DOUBLE"
					},
					{
						"name": "LONGITUDE",
						"type": "DOUBLE"
					},
					{
						"name": "UPDATE_TIMESTAMP",
						"type": "INT96"
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_temp_sink')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_fabrictest",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Misc"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileSystem": "tempsink"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_01_all_files_landing_to_raw')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy Customers Landing to Raw",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.00:10:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "JsonSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "JsonWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "$['CUSTOMER_ID']"
										},
										"sink": {
											"path": "$['CUSTOMER_ID']"
										}
									},
									{
										"source": {
											"path": "$['FULL_NAME']"
										},
										"sink": {
											"path": "$['FULL_NAME']"
										}
									},
									{
										"source": {
											"path": "$['EMAIL_ADDRESS']"
										},
										"sink": {
											"path": "$['EMAIL_ADDRESS']"
										}
									}
								]
							}
						},
						"inputs": [
							{
								"referenceName": "ds_landing_fabrictest_customers",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_raw_fabrictest_customers",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Copy Order Items Landing to Raw",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy Customers Landing to Raw",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.00:10:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "ORDER_ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ORDER_ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "LINE_ITEM_ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "LINE_ITEM_ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "PRODUCT_ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PRODUCT_ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "UNIT_PRICE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "UNIT_PRICE",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "QUANTITY",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "QUANTITY",
											"type": "String",
											"physicalType": "String"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_landing_fabrictest_items",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_raw_fabrictest_items",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Copy Orders Landing to Raw",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy Order Items Landing to Raw",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.00:10:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "ParquetSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "ParquetReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "ORDER_ID",
											"type": "String",
											"physicalType": "UTF8"
										},
										"sink": {
											"name": "ORDER_ID",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ORDER_DATETIME",
											"type": "String",
											"physicalType": "UTF8"
										},
										"sink": {
											"name": "ORDER_DATETIME",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CUSTOMER_ID",
											"type": "String",
											"physicalType": "UTF8"
										},
										"sink": {
											"name": "CUSTOMER_ID",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ORDER_STATUS",
											"type": "String",
											"physicalType": "UTF8"
										},
										"sink": {
											"name": "ORDER_STATUS",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "STORE_ID",
											"type": "String",
											"physicalType": "UTF8"
										},
										"sink": {
											"name": "STORE_ID",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_landing_orders",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_raw_orders",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Copy Products Landing to Raw",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy Orders Landing to Raw",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.00:10:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "JsonSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "JsonWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "ds_landing_fabrictest_products",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_raw_fabrictest_products",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Copy Stores Landing to Raw",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy Products Landing to Raw",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.00:10:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "JsonSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "JsonWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "ds_landing_fabrictest_stores",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_raw_fabrictest_stores",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_raw_orders')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_copy_files_stores')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy Json Stories files",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.00:10:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFileName": "*.json",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "JsonSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "MergeFiles"
								},
								"formatSettings": {
									"type": "JsonWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "ds_source_stories",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_sink_stories",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stories')]",
				"[concat(variables('factoryId'), '/datasets/ds_sink_stories')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_all_cleansed_to_structured')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_cleansed_orders",
								"type": "DatasetReference"
							},
							"name": "orders"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_order_items",
								"type": "DatasetReference"
							},
							"name": "orderitems"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_stores",
								"type": "DatasetReference"
							},
							"name": "stores"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_products",
								"type": "DatasetReference"
							},
							"name": "products"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_structured_orders",
								"type": "DatasetReference"
							},
							"name": "StructuredOrdersSink"
						},
						{
							"dataset": {
								"referenceName": "ds_structured_stores",
								"type": "DatasetReference"
							},
							"name": "StructuredStoresSink"
						},
						{
							"dataset": {
								"referenceName": "ds_structured_products",
								"type": "DatasetReference"
							},
							"name": "StructuredProducts"
						}
					],
					"transformations": [
						{
							"name": "OrderWithOrderItem"
						},
						{
							"name": "orderDropColumns"
						},
						{
							"name": "orderItemDropColumns"
						},
						{
							"name": "CalcSubtotalAndTimeStamp"
						},
						{
							"name": "CalcTimeStamp"
						},
						{
							"name": "CalcTimeStampP"
						}
					],
					"scriptLines": [
						"source(output(",
						"          ORDER_ID as integer,",
						"          ORDER_DATE as date,",
						"          CUSTOMER_ID as integer,",
						"          STORE_ID as integer,",
						"          UPDATED_TIMESTAMP as timestamp,",
						"          ORDER_STATUS as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> orders",
						"source(output(",
						"          ORDER_ID as integer,",
						"          PRODUCT_ID as integer,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as integer,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> orderitems",
						"source(output(",
						"          STORE_ID as integer,",
						"          STORE_NAME as string,",
						"          LATITUDE as double,",
						"          LONGITUDE as double,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> stores",
						"source(output(",
						"          PRODUCT_ID as integer,",
						"          PRODUCT_NAME as string,",
						"          UNIT_PRICE as double,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> products",
						"orderDropColumns, orderItemDropColumns join(orderDropColumns@ORDER_ID == orderItemDropColumns@ORDER_ID,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> OrderWithOrderItem",
						"orders select(mapColumn(",
						"          ORDER_ID,",
						"          ORDER_DATE,",
						"          CUSTOMER_ID,",
						"          STORE_ID,",
						"          ORDER_STATUS",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> orderDropColumns",
						"orderitems select(mapColumn(",
						"          ORDER_ID,",
						"          PRODUCT_ID,",
						"          UNIT_PRICE,",
						"          QUANTITY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> orderItemDropColumns",
						"OrderWithOrderItem derive(SUBTOTAL = UNIT_PRICE * QUANTITY,",
						"          UPDATED_TIMESTAMP = currentUTC()) ~> CalcSubtotalAndTimeStamp",
						"stores derive(UPDATE_TIMESTAMP = currentUTC()) ~> CalcTimeStamp",
						"products derive(UPDATE_TIMESTAMP = currentUTC()) ~> CalcTimeStampP",
						"CalcSubtotalAndTimeStamp sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ORDER_ID as integer,",
						"          ORDER_DATE as date,",
						"          CUSTOMER_ID as integer,",
						"          STORE_ID as integer,",
						"          ORDER_STATUS as string,",
						"          PRODUCT_ID as integer,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as integer,",
						"          SUBTOTAL as double,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StructuredOrdersSink",
						"CalcTimeStamp sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          STORE_ID as integer,",
						"          STORE_NAME as string,",
						"          LATITUDE as double,",
						"          LONGITUDE as double,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StructuredStoresSink",
						"CalcTimeStampP sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          PRODUCT_ID as integer,",
						"          PRODUCT_NAME as string,",
						"          UNIT_PRICE as double,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StructuredProducts"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_structured_orders')]",
				"[concat(variables('factoryId'), '/datasets/ds_structured_stores')]",
				"[concat(variables('factoryId'), '/datasets/ds_structured_products')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_all_raw_to_cleansed_parquet')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_raw_orders",
								"type": "DatasetReference"
							},
							"name": "OrdersRaw"
						},
						{
							"dataset": {
								"referenceName": "ds_raw_fabrictest_items",
								"type": "DatasetReference"
							},
							"name": "OrdersItemRaw"
						},
						{
							"dataset": {
								"referenceName": "ds_raw_fabrictest_products",
								"type": "DatasetReference"
							},
							"name": "ProductsRaw"
						},
						{
							"dataset": {
								"referenceName": "ds_raw_fabrictest_stores",
								"type": "DatasetReference"
							},
							"name": "StoresRaw"
						},
						{
							"dataset": {
								"referenceName": "ds_raw_fabrictest_customers",
								"type": "DatasetReference"
							},
							"name": "CustomersRaw"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_cleansed_orders",
								"type": "DatasetReference"
							},
							"name": "OrdersSink"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_order_items",
								"type": "DatasetReference"
							},
							"name": "OrdersItemSink"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_customers",
								"type": "DatasetReference"
							},
							"name": "CustomersSink"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_products",
								"type": "DatasetReference"
							},
							"name": "ProductsSink"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_stores",
								"type": "DatasetReference"
							},
							"name": "StoresSink"
						}
					],
					"transformations": [
						{
							"name": "OrderDateAndUpdatedTimeStamp"
						},
						{
							"name": "CastDataTypesOrders"
						},
						{
							"name": "DropOrderDateTimeAndReorder"
						},
						{
							"name": "UpdatedTimestamp"
						},
						{
							"name": "UpdatedTimeStampProducts"
						},
						{
							"name": "UpdatedTimeStampStores"
						},
						{
							"name": "CastDataTypesOrderItems"
						},
						{
							"name": "CastDataTypesProducts"
						},
						{
							"name": "CastDataTypesStores"
						},
						{
							"name": "CastDataTypesCustomers"
						},
						{
							"name": "DropLineItemID"
						},
						{
							"name": "DropWebAddressAndReorder"
						},
						{
							"name": "UpdatedTimestampCustomers"
						}
					],
					"scriptLines": [
						"source(output(",
						"          ORDER_ID as string,",
						"          ORDER_DATETIME as string,",
						"          CUSTOMER_ID as string,",
						"          ORDER_STATUS as string,",
						"          STORE_ID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> OrdersRaw",
						"source(output(",
						"          ORDER_ID as short,",
						"          LINE_ITEM_ID as short,",
						"          PRODUCT_ID as short,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as short",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> OrdersItemRaw",
						"source(output(",
						"          PRODUCT_ID as short,",
						"          PRODUCT_NAME as string,",
						"          UNIT_PRICE as double",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'documentPerLine') ~> ProductsRaw",
						"source(output(",
						"          LATITUDE as double,",
						"          LONGITUDE as double,",
						"          STORE_ID as short,",
						"          STORE_NAME as string,",
						"          WEB_ADDRESS as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'documentPerLine') ~> StoresRaw",
						"source(output(",
						"          CUSTOMER_ID as short,",
						"          EMAIL_ADDRESS as string,",
						"          FULL_NAME as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'documentPerLine') ~> CustomersRaw",
						"OrdersRaw derive(ORDER_DATE = toDate(ORDER_DATETIME,'dd-MMM-yy HH.mm.ss.SS'),",
						"          UPDATED_TIMESTAMP = currentUTC()) ~> OrderDateAndUpdatedTimeStamp",
						"OrderDateAndUpdatedTimeStamp cast(output(",
						"          ORDER_ID as integer,",
						"          ORDER_DATETIME as string,",
						"          CUSTOMER_ID as integer,",
						"          ORDER_STATUS as string,",
						"          STORE_ID as integer,",
						"          ORDER_DATE as date,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     errors: true) ~> CastDataTypesOrders",
						"CastDataTypesOrders select(mapColumn(",
						"          ORDER_ID,",
						"          ORDER_DATE,",
						"          CUSTOMER_ID,",
						"          ORDER_STATUS,",
						"          STORE_ID,",
						"          UPDATED_TIMESTAMP",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> DropOrderDateTimeAndReorder",
						"OrdersItemRaw derive(UPDATED_TIMESTAMP = currentUTC()) ~> UpdatedTimestamp",
						"ProductsRaw derive(UPDATE_TIMESTAMP = currentUTC()) ~> UpdatedTimeStampProducts",
						"StoresRaw derive(UPDATE_TIMESTAMP = currentUTC()) ~> UpdatedTimeStampStores",
						"UpdatedTimestamp cast(output(",
						"          ORDER_ID as integer,",
						"          LINE_ITEM_ID as integer,",
						"          PRODUCT_ID as integer,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as integer,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     errors: true) ~> CastDataTypesOrderItems",
						"UpdatedTimeStampProducts cast(output(",
						"          PRODUCT_ID as integer,",
						"          PRODUCT_NAME as string,",
						"          UNIT_PRICE as double,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     errors: true) ~> CastDataTypesProducts",
						"UpdatedTimeStampStores cast(output(",
						"          LATITUDE as double,",
						"          LONGITUDE as double,",
						"          STORE_ID as integer,",
						"          STORE_NAME as string,",
						"          WEB_ADDRESS as string,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     errors: true) ~> CastDataTypesStores",
						"CustomersRaw cast(output(",
						"          CUSTOMER_ID as integer,",
						"          EMAIL_ADDRESS as string,",
						"          FULL_NAME as string",
						"     ),",
						"     errors: true) ~> CastDataTypesCustomers",
						"CastDataTypesOrderItems select(mapColumn(",
						"          ORDER_ID,",
						"          PRODUCT_ID,",
						"          UNIT_PRICE,",
						"          QUANTITY,",
						"          UPDATED_TIMESTAMP",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> DropLineItemID",
						"CastDataTypesStores select(mapColumn(",
						"          STORE_ID,",
						"          STORE_NAME,",
						"          LATITUDE,",
						"          LONGITUDE,",
						"          UPDATE_TIMESTAMP",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> DropWebAddressAndReorder",
						"CastDataTypesCustomers derive(UPDATED_TIMESTAMP = currentUTC()) ~> UpdatedTimestampCustomers",
						"DropOrderDateTimeAndReorder sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ORDER_ID as integer,",
						"          ORDER_DATE as date,",
						"          CUSTOMER_ID as integer,",
						"          STORE_ID as integer,",
						"          UPDATED_TIMESTAMP as timestamp,",
						"          ORDER_STATUS as string",
						"     ),",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> OrdersSink",
						"DropLineItemID sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ORDER_ID as integer,",
						"          PRODUCT_ID as integer,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as integer,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> OrdersItemSink",
						"UpdatedTimestampCustomers sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          CUSTOMER_ID as integer,",
						"          EMAIL_ADDRESS as string,",
						"          FULL_NAME as string,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> CustomersSink",
						"CastDataTypesProducts sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          PRODUCT_ID as integer,",
						"          PRODUCT_NAME as string,",
						"          UNIT_PRICE as double,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> ProductsSink",
						"DropWebAddressAndReorder sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          STORE_ID as integer,",
						"          STORE_NAME as string,",
						"          LATITUDE as double,",
						"          LONGITUDE as double,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StoresSink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_raw_orders')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_all_structured_to_analytics')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_structured_orders",
								"type": "DatasetReference"
							},
							"name": "StructuredOrders"
						},
						{
							"dataset": {
								"referenceName": "ds_structured_stores",
								"type": "DatasetReference"
							},
							"name": "StructuredStores"
						},
						{
							"dataset": {
								"referenceName": "ds_structured_products",
								"type": "DatasetReference"
							},
							"name": "StructuredProducts"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_analytics_products_orders_monthly",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"dataset": {
								"referenceName": "ds_analytics_stores_orders_monthly",
								"type": "DatasetReference"
							},
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "derMonthYear"
						},
						{
							"name": "SelectColumns"
						},
						{
							"name": "JoinProductsOrders"
						},
						{
							"name": "SumByProductMonthYearAndStatus"
						},
						{
							"name": "sort1"
						},
						{
							"name": "JoinStoresOrders"
						},
						{
							"name": "SumByStoresMontyYearStatus"
						},
						{
							"name": "sort2"
						},
						{
							"name": "ExcludeCancelled"
						}
					],
					"scriptLines": [
						"source(output(",
						"          ORDER_ID as integer,",
						"          ORDER_DATE as date,",
						"          CUSTOMER_ID as integer,",
						"          STORE_ID as integer,",
						"          ORDER_STATUS as string,",
						"          PRODUCT_ID as integer,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as integer,",
						"          SUBTOTAL as double,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     partitionRootPath: 'orders',",
						"     format: 'parquet') ~> StructuredOrders",
						"source(output(",
						"          STORE_ID as integer,",
						"          STORE_NAME as string,",
						"          LATITUDE as double,",
						"          LONGITUDE as double,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> StructuredStores",
						"source(output(",
						"          PRODUCT_ID as integer,",
						"          PRODUCT_NAME as string,",
						"          UNIT_PRICE as double,",
						"          UPDATE_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> StructuredProducts",
						"ExcludeCancelled derive(MONTH_YEAR = /* concatWS(\"-\",iif(month(ORDER_DATE) >= 10, toString(month(ORDER_DATE)), concat(\"0\",toString(month(ORDER_DATE)))), toString(year(ORDER_DATE))) */\r",
						"toString(ORDER_DATE, \"MM-YYYY\")) ~> derMonthYear",
						"derMonthYear select(mapColumn(",
						"          STORE_ID,",
						"          ORDER_STATUS,",
						"          PRODUCT_ID,",
						"          SUBTOTAL,",
						"          MONTH_YEAR",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumns",
						"StructuredProducts, SelectColumns join(StructuredProducts@PRODUCT_ID == SelectColumns@PRODUCT_ID,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinProductsOrders",
						"JoinProductsOrders aggregate(groupBy(PRODUCT_NAME,",
						"          MONTH_YEAR,",
						"          ORDER_STATUS),",
						"     TOTAL_AMOUNT = round(sum(SUBTOTAL),2)) ~> SumByProductMonthYearAndStatus",
						"SumByProductMonthYearAndStatus sort(asc(PRODUCT_NAME, true),",
						"     desc(MONTH_YEAR, true),",
						"     asc(ORDER_STATUS, true)) ~> sort1",
						"StructuredStores, SelectColumns join(StructuredStores@STORE_ID == SelectColumns@STORE_ID,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinStoresOrders",
						"JoinStoresOrders aggregate(groupBy(STORE_NAME,",
						"          LATITUDE,",
						"          LONGITUDE,",
						"          ORDER_STATUS,",
						"          MONTH_YEAR),",
						"     TOTAL_AMOUNT = round(sum(SUBTOTAL),2)) ~> SumByStoresMontyYearStatus",
						"SumByStoresMontyYearStatus sort(asc(STORE_NAME, true),",
						"     asc(LATITUDE, true),",
						"     asc(LONGITUDE, true),",
						"     desc(MONTH_YEAR, true),",
						"     asc(ORDER_STATUS, true)) ~> sort2",
						"StructuredOrders filter(ORDER_STATUS != \"CANCELLED\") ~> ExcludeCancelled",
						"sort1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['productsOrdersMonthly.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1",
						"sort2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['storesOrdersMonthly.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_structured_orders')]",
				"[concat(variables('factoryId'), '/datasets/ds_structured_stores')]",
				"[concat(variables('factoryId'), '/datasets/ds_structured_products')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_filter_sort_agg')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_cleansed_orders",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_order_items",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_order_items",
								"type": "DatasetReference"
							},
							"name": "source3"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_orders",
								"type": "DatasetReference"
							},
							"name": "Orders"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_customers",
								"type": "DatasetReference"
							},
							"name": "Customers"
						},
						{
							"dataset": {
								"referenceName": "ds_cleansed_orders",
								"type": "DatasetReference"
							},
							"name": "split"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_temp_sink",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"dataset": {
								"referenceName": "ds_temp_sink",
								"type": "DatasetReference"
							},
							"name": "sink2"
						},
						{
							"dataset": {
								"referenceName": "ds_temp_sink",
								"type": "DatasetReference"
							},
							"name": "sink3"
						},
						{
							"dataset": {
								"referenceName": "ds_temp_sink",
								"type": "DatasetReference"
							},
							"name": "sink4"
						},
						{
							"dataset": {
								"referenceName": "ds_temp_sink",
								"type": "DatasetReference"
							},
							"name": "sink5"
						}
					],
					"transformations": [
						{
							"name": "filter1"
						},
						{
							"name": "sort1"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "join1"
						},
						{
							"name": "split1"
						},
						{
							"name": "union2"
						}
					],
					"scriptLines": [
						"source(output(",
						"          ORDER_ID as integer,",
						"          ORDER_DATE as date,",
						"          CUSTOMER_ID as integer,",
						"          STORE_ID as integer,",
						"          UPDATED_TIMESTAMP as timestamp,",
						"          ORDER_STATUS as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source1",
						"source(output(",
						"          ORDER_ID as integer,",
						"          PRODUCT_ID as integer,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as integer,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source2",
						"source(output(",
						"          ORDER_ID as integer,",
						"          PRODUCT_ID as integer,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as integer,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source3",
						"source(output(",
						"          ORDER_ID as integer,",
						"          ORDER_DATE as date,",
						"          CUSTOMER_ID as integer,",
						"          STORE_ID as integer,",
						"          UPDATED_TIMESTAMP as timestamp,",
						"          ORDER_STATUS as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> Orders",
						"source(output(",
						"          CUSTOMER_ID as integer,",
						"          EMAIL_ADDRESS as string,",
						"          FULL_NAME as string,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> Customers",
						"source(output(",
						"          ORDER_ID as integer,",
						"          ORDER_DATE as date,",
						"          CUSTOMER_ID as integer,",
						"          STORE_ID as integer,",
						"          UPDATED_TIMESTAMP as timestamp,",
						"          ORDER_STATUS as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> split",
						"source1 filter(/* ORDER_STATUS == 'REFUNDED' || ORDER_STATUS == 'CANCELLED' */\r",
						"/* ORDER_DATE ==toDate('2022-01-07') */\r",
						"and(ORDER_DATE ==toDate('2022-01-07'), ORDER_STATUS == 'CANCELLED')) ~> filter1",
						"source2 sort(desc(UNIT_PRICE, false)) ~> sort1",
						"source3 aggregate(groupBy(ORDER_ID),",
						"     TOTAL_ORDER_QUANTITY = sum(QUANTITY),",
						"          MIN_UNIT_PRICE_IN_ORDER = min(UNIT_PRICE)) ~> aggregate1",
						"Orders, Customers join(Orders@CUSTOMER_ID == Customers@CUSTOMER_ID,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"split split(ORDER_STATUS == 'COMPLETE',",
						"     ORDER_STATUS == 'REFUNDED',",
						"     disjoint: false) ~> split1@(COMPLETE, REFUNDED, REST)",
						"split1@COMPLETE, split1@REST, split1@REFUNDED union(byName: true)~> union2",
						"filter1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     partitionFileNames:['filter_sink.parquet'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1",
						"sort1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     partitionFileNames:['sort_sink.parquet'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink2",
						"aggregate1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     partitionFileNames:['agg_sink.parquet'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink3",
						"join1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     partitionFileNames:['orders_sink.parquet'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink4",
						"union2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     partitionFileNames:['split_union_sink.parquet'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink5"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_temp_sink')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_test_1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_raw_fabrictest_items",
								"type": "DatasetReference"
							},
							"name": "OrderItemsRaw"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_sink_order_items_df",
								"type": "DatasetReference"
							},
							"name": "OrderItemsTestSink"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          ORDER_ID as short,",
						"          LINE_ITEM_ID as short,",
						"          PRODUCT_ID as short,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as short",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     partitionBy('key',",
						"          0,",
						"          PRODUCT_ID",
						"     )) ~> OrderItemsRaw",
						"OrderItemsRaw sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['xxx.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> OrderItemsTestSink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_sink_order_items_df')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_orders_partition_raw_to_cleansed')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_raw_orders",
								"type": "DatasetReference"
							},
							"name": "OrdersRaw"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_cleansed_orders",
								"type": "DatasetReference"
							},
							"name": "OrdersSink"
						}
					],
					"transformations": [
						{
							"name": "OrderDateAndUpdatedTimeStamp"
						},
						{
							"name": "CastDataTypesOrders"
						},
						{
							"name": "DropOrderDateTimeAndReorder"
						}
					],
					"scriptLines": [
						"source(output(",
						"          ORDER_ID as string,",
						"          ORDER_DATETIME as string,",
						"          CUSTOMER_ID as string,",
						"          ORDER_STATUS as string,",
						"          STORE_ID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> OrdersRaw",
						"OrdersRaw derive(ORDER_DATE = toDate(ORDER_DATETIME,'dd-MMM-yy HH.mm.ss.SS'),",
						"          UPDATED_TIMESTAMP = currentUTC()) ~> OrderDateAndUpdatedTimeStamp",
						"OrderDateAndUpdatedTimeStamp cast(output(",
						"          ORDER_ID as integer,",
						"          ORDER_DATETIME as string,",
						"          CUSTOMER_ID as integer,",
						"          ORDER_STATUS as string,",
						"          STORE_ID as integer,",
						"          ORDER_DATE as date,",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     errors: true) ~> CastDataTypesOrders",
						"CastDataTypesOrders select(mapColumn(",
						"          ORDER_ID,",
						"          ORDER_DATE,",
						"          CUSTOMER_ID,",
						"          ORDER_STATUS,",
						"          STORE_ID,",
						"          UPDATED_TIMESTAMP",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> DropOrderDateTimeAndReorder",
						"DropOrderDateTimeAndReorder sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ORDER_ID as integer,",
						"          ORDER_DATE as date,",
						"          CUSTOMER_ID as integer,",
						"          STORE_ID as integer,",
						"          UPDATED_TIMESTAMP as timestamp,",
						"          ORDER_STATUS as string",
						"     ),",
						"     format: 'parquet',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('key',",
						"          0,",
						"          ORDER_STATUS",
						"     )) ~> OrdersSink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_raw_orders')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pipeline1')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "pl_test_partition",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "ds_orders_partition_raw_to_cleansed",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"OrdersRaw": {},
									"OrdersSink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/ds_orders_partition_raw_to_cleansed')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_02_all_files_raw_to_cleansed')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "raw to cleansed",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.00:20:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_all_raw_to_cleansed_parquet",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"OrdersRaw": {},
									"OrdersItemRaw": {},
									"ProductsRaw": {},
									"StoresRaw": {},
									"CustomersRaw": {},
									"OrdersSink": {},
									"OrdersItemSink": {},
									"CustomersSink": {},
									"ProductsSink": {},
									"StoresSink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_all_raw_to_cleansed_parquet')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_03_all_files_clenased_to_structured')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "cleansed To Structured",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.00:10:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_all_cleansed_to_structured",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"orders": {},
									"orderitems": {},
									"stores": {},
									"products": {},
									"StructuredOrdersSink": {},
									"StructuredStoresSink": {},
									"StructuredProducts": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_all_cleansed_to_structured')]"
			]
		}
	]
}